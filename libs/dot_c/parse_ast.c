#include "./dot_h/parse_ast.h"
#include "dot_h/ast.h"
#include <cstdio>
#include <stddef.h>
#include <stdio.h>

void
code_gen(Node* h, FILE* o_fpt) {
    fprintf(o_fpt, "/* GENERATED BY QUEUE_COMPILER */\n\n");
    fprintf(o_fpt, "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n");

    parse_nodes(h, o_fpt);
}

void
parse_nodes(Node* n, FILE* o_fpt) {
    if (!n) return;

    switch (n->node_type) {
        case AST_MULTI_STMT:
            parse_nodes(n->op1, o_fpt);
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_SINGLE_STMT:
            parse_nodes(n->op1, o_fpt);
            break;

/* ------------ FUNCTION COMMANDS ------------ */

        case AST_FUNCTION_DECL:
        case AST_FUNCTION:
            fprintf(
                o_fpt,
                "%s %s(",
                str_types[n->function.function_header.type % 7],
                n->constant.name
            );

            for (int i = 0; i < n->function.count; ++i) {
                if (i != 0)
                    fprintf(o_fpt, ",");

                string type = str_types[n->function.args[i]->constant.type % 7];
                if (n->function.args[i]->constant.is_ptr)
                    type = concat_c(type, '*');
                if(n->function.args[i]->constant.is_unsign)
                    type = concat("unsigned ", type);

                fprintf(o_fpt, "%s ", type);
                parse_nodes(n->function.args[i], o_fpt);
            }
            fprintf(o_fpt, ")");

            if (n->node_type != AST_FUNCTION_DECL) {
                fprintf(o_fpt, "{\n");
                parse_nodes(n->op1, o_fpt);
                fprintf(o_fpt, "}\n\n");
            }
            else
                fprintf(o_fpt, ";\n\n");
            break;

        case AST_RET:
            fprintf(o_fpt,"return ");

            if (n->op1)
                parse_nodes(n->op1, o_fpt);

            fprintf(o_fpt,";\n");
            break;

        case AST_CALL:
            const Node* f = n->op1;

            fprintf(o_fpt, "%s(", f->function.function_header.name);
            for (int i = 0; i < f->function.count; ++i) {
                if (i != 0)
                    fprintf(o_fpt, ",");

                parse_nodes(f->function.args[i], o_fpt);
            }

            fprintf(o_fpt, ")");

            if (n->is_standalone)
                fprintf(o_fpt, ";\n");

            break;

/* ------------ FUNCTION COMMANDS ------------ */

/* ------------ IF-ELSE ------------ */

        case AST_ELSE_IF:
        case AST_IF:
            if (n->node_type == AST_IF)
                fprintf(o_fpt,"if(");
            else
                fprintf(o_fpt,"else if(");

            parse_nodes(n->cmd.if_else.condition, o_fpt);
            fprintf(o_fpt,"){\n");
            parse_nodes(n->cmd.if_else.if_body, o_fpt);
            fprintf(o_fpt,"}\n");

            if (n->cmd.if_else.else_) {
                Node* else_node = (Node*)malloc(sizeof(Node));
                if (!else_node) exit(1);
                else_node->cmd = *(n->cmd.if_else.else_);

                if (else_node->cmd.if_else.condition)
                    else_node->node_type = AST_ELSE_IF;
                else
                    else_node->node_type = AST_ELSE;

                parse_nodes(else_node, o_fpt);

                free(else_node);
            }
            break;

        case AST_ELSE:
            fprintf(o_fpt,"else{\n");
            parse_nodes(n->cmd.if_else.if_body, o_fpt);
            fprintf(o_fpt,"}\n");
            break;

        case AST_LPAREN:
            fprintf(o_fpt,"(");
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,")");
            break;

        case AST_G:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,">");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_EQ:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"==");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_NEQ:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"!=");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_LE:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"<=");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_L:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"<");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_GE:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,">=");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_AND:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"&&");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_OR:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"||");
            parse_nodes(n->op2, o_fpt);
            break;

/* ------------ IF-ELSE ------------ */

/* ------------ CYCLES ------------ */

        case AST_FOR:
            fprintf(o_fpt,"for(;");
            parse_nodes(n->cmd.cycles.for_cycle.condition, o_fpt);
            fprintf(o_fpt,";");
            parse_nodes(n->cmd.cycles.for_cycle.iter, o_fpt);
            fprintf(o_fpt,"){\n");
            parse_nodes(n->cmd.cycles.for_cycle.for_body, o_fpt);
            fprintf(o_fpt,"}\n");
            break;

        case AST_WHILE:
            fprintf(o_fpt,"while(");
            parse_nodes(n->cmd.cycles.while_cycle.condition, o_fpt);
            fprintf(o_fpt,"){\n");
            parse_nodes(n->cmd.cycles.while_cycle.while_body, o_fpt);
            fprintf(o_fpt,"}\n");
            break;

/* ------------ CYCLES ------------ */

/* ------------ I/O ------------ */

        case AST_OUT:
            fprintf(
                o_fpt,
                "printf(\"%s\"",
                n->cmd.io.format
            );

            for (int i = 0; i < n->cmd.io.args_count; ++i) {
                fprintf(o_fpt, ",");
                parse_nodes(n->cmd.io.args[i], o_fpt);
            }
            fprintf(o_fpt, ");\n");
            break;

        case AST_IN:
            if (comp(n->cmd.io.format, "%c"))
                fprintf(o_fpt, "getc(stdin);\n");

            fprintf(
                o_fpt,
                "scanf(\"%s\"",
                n->cmd.io.format
            );

            for (int i = 0; i < n->cmd.io.args_count; ++i) {
                fprintf(o_fpt, ",");
                parse_nodes(n->cmd.io.args[i], o_fpt);
            }
            fprintf(o_fpt, ");\n");
            break;

/* ------------ I/O ------------ */

/* ------------ UNARY OP'S. ------------ */

        case AST_DEREF:
            fprintf(o_fpt,"*");
            parse_nodes(n->op1, o_fpt);
            break;

        case AST_GET_ADDR:
            fprintf(o_fpt, "&");
            parse_nodes(n->op1, o_fpt);
            break;

        case AST_INC_PREF:
            fprintf(o_fpt,"++");
            parse_nodes(n->op1, o_fpt);
            break;

        case AST_DEC_PREF:
            fprintf(o_fpt,"--");
            parse_nodes(n->op1, o_fpt);
            break;

        case AST_INC_POST:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"++");
            break;

        case AST_DEC_POST:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"--");
            break;

/* ------------ UNARY OP'S. ------------ */

/* ------------ BINARY OP'S. ------------ */

        case AST_PLUS:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"+");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_MINUS:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"-");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_MULTI:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"*");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_DIV:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"/");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_REM:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"%%");
            parse_nodes(n->op2, o_fpt);
            break;

/* ------------ BINARY OP'S. ------------ */

/* ------------ EXPR'S ------------ */

        case AST_LIT_CNST:
            fprintf(
                o_fpt,
                "%s",
                n->constant.name
            );
            break;

        case AST_NUM:
            if (n->constant.type == TYPE_INT)
                fprintf(o_fpt, "%d", n->constant.int_value);
            else if (n->constant.type == TYPE_LONG)
                fprintf(o_fpt, "%ld", n->constant.long_value);
            else if (n->constant.type == TYPE_FLT)
                fprintf(o_fpt, "%f", n->constant.flt_value);
            break;

        case AST_NULL_VALUE:
            fprintf(o_fpt, "NULL");
            break;

        case AST_CHAR_VALUE:
            fprintf(o_fpt, "'%c'", n->constant.char_value);
            break;

        case AST_BOOLIAN_VALUE:
            fprintf(o_fpt, "%s", n->constant.bool_value ? "true" : "false");
            break;

        case AST_ASSIGN:
        case AST_ADD_ASSIGN:
        case AST_REDUCE_ASSIGN:
        case AST_MUL_ASSIGN:
        case AST_DIV_ASSIGN:
        case AST_REM_ASSIGN:
            if (n->op1->constant.type != TYPE_NULL && n->op1->node_type != AST_APPEAL_TO_ARR_CELL) {
                string type = NULL;
                if (n->op1->constant.is_unsign)
                    type = "unsigned ";

                type = !type ? str_types[n->op1->constant.type % 7] : concat(type, str_types[n->op1->constant.type % 7]);
                if (n->op1->constant.is_ptr)
                    type = concat_c(type, '*');

                fprintf(o_fpt, "%s ", type);
            }

            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt, "%s", DEFINE_ASSIGN(n->node_type));
            parse_nodes(n->op2, o_fpt);
            fprintf(o_fpt, ";\n");
            break;

/* ------------ EXPR'S ------------ */

/* ------------ ARRAY'S ------------ */

        case AST_ARRAY_FULL_INIT:
            string farr_type = str_types[n->array.head.type % 7];

            if (n->array.head.is_unsign) farr_type = concat("unsigned ", farr_type);
            if (n->array.head.is_ptr) farr_type = concat_c(farr_type, '*');

            fprintf(o_fpt, "%s %s[%u] = {", farr_type, n->array.head.name, n->array.size);

            for (size_t i = 0; i < n->array.size; ++i) {
                parse_nodes(n->array.data[i], o_fpt);
                
                fprintf(o_fpt, ",");
            }

            fprintf(o_fpt, "};\n");
            break;
        
        case AST_EMPTY_ARRAY:
            string earr_type = str_types[n->array.head.type % 7];
            
            if (n->array.head.is_unsign) earr_type = concat("unsigned ", earr_type);
            if (n->array.head.is_ptr) earr_type = concat_c(earr_type, '*');
            
            fprintf(o_fpt, "%s %s[%u];\n", earr_type, n->array.head.name, n->array.size);
            break;

        case AST_ARRAY_AS_FUNC_PARAM:
            fprintf(o_fpt, "%s[%u]", n->array.head.name, n->array.size);
            break;

        case AST_ARRAY_PARTIALLY_INIT:
            string parr_type = str_types[n->array.head.type % 7];

            if (n->array.head.is_unsign) parr_type = concat("unsigned ", parr_type);
            if (n->array.head.is_ptr) parr_type = concat_c(parr_type, '*');

            fprintf(o_fpt, "%s %s[%u];\n", parr_type, n->array.head.name, n->array.size);

            for(size_t i = 0; i < n->array.size; ++i)
                if(n->array.data[i]->node_type != AST_UNDEF){
                    fprintf(o_fpt, "%s[%zu] = ", n->array.head.name, i);
                    parse_nodes(n, o_fpt);
                    fprintf(o_fpt, ";\n");
                }

            break;

        case AST_APPEAL_TO_ARR_CELL:
            fprintf(o_fpt, "%s[%s]", n->constant.name, n->op1->constant.name);
            break;

/* ------------ ARRAY'S ------------ */

/* ------------ STRUCT'S ------------ */

        case AST_STRUCT_DECL:
            fprintf(o_fpt, "struct %s;\n", n->_struct.name);
            break;
        
        case AST_STRUCT:
            fprintf(o_fpt, "struct %s{\n", n->_struct.name);

            for(int i = 0; i < n->_struct.count; ++i)
                parse_nodes(n->_struct.fields[i], o_fpt);

            fprintf(o_fpt, "};\n");
            break;

/* ------------ STRUCT'S ------------ */

        default:
            break;
    }
}