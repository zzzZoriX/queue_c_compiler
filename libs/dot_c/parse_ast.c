#include "./dot_h/parse_ast.h"

void
code_gen(Node* h, FILE* o_fpt) {
    fprintf(o_fpt, "/* GENERATED BY QUEUE_COMPILER */\n\n");
    fprintf(o_fpt, "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n");

    parse_nodes(h, o_fpt);
}

void
parse_nodes(Node* n, FILE* o_fpt) {
    if (!n) return;

    switch (n->node_type) {
        case AST_MULTI_STMT:
            parse_nodes(n->op1, o_fpt);
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_SINGLE_STMT:
            parse_nodes(n->op1, o_fpt);
            break;

/* ------------ FUNCTION COMMANDS ------------ */

        case AST_FUNCTION_DECL:
        case AST_FUNCTION:
            fprintf(
                o_fpt,
                "%s %s(",
                str_types[n->function.function_header.type % 7],
                n->constant.name
            );

            for (int i = 0; i < n->function.count; ++i) {
                if (i != 0)
                    fprintf(o_fpt, ",");

                string type = str_types[n->function.args[i]->constant.type % 7];
                if (n->function.args[i]->constant.is_ptr)
                    type = concat_c(type, '*');

                fprintf(o_fpt, "%s ", type);
                parse_nodes(n->function.args[i], o_fpt);
            }
            fprintf(o_fpt, ")");

            if (n->node_type != AST_FUNCTION_DECL) {
                fprintf(o_fpt, "{\n");
                parse_nodes(n->op1, o_fpt);
                fprintf(o_fpt, "}\n\n");
            }
            else
                fprintf(o_fpt, ";\n\n");
            break;

        case AST_RET:
            fprintf(o_fpt,"return ");

            if (n->op1)
                parse_nodes(n->op1, o_fpt);

            fprintf(o_fpt,";\n");
            break;

        case AST_CALL:
            Node* f = n->op1;

            fprintf(o_fpt, "%s(", f->function.function_header.name);
            for (int i = 0; i < f->function.count; ++i) {
                if (i != 0)
                    fprintf(o_fpt, ",");

                parse_nodes(f->function.args[i], o_fpt);
            }

            fprintf(o_fpt, ");\n");
            break;

/* ------------ FUNCTION COMMANDS ------------ */

/* ------------ IF-ELSE ------------ */

        case AST_ELSE_IF:
        case AST_IF:
            if (n->node_type == AST_IF)
                fprintf(o_fpt,"if(");
            else
                fprintf(o_fpt,"else if(");

            parse_nodes(n->cmd.if_else.condition, o_fpt);
            fprintf(o_fpt,"){\n");
            parse_nodes(n->cmd.if_else.if_body, o_fpt);
            fprintf(o_fpt,"}\n");

            if (n->cmd.if_else.else_) {
                Node* else_node = (Node*)malloc(sizeof(Node));
                if (!else_node) exit(1);
                else_node->cmd = *(n->cmd.if_else.else_);

                if (else_node->cmd.if_else.condition)
                    else_node->node_type = AST_ELSE_IF;
                else
                    else_node->node_type = AST_ELSE;

                parse_nodes(else_node, o_fpt);

                free(else_node);
            }
            break;

        case AST_ELSE:
            fprintf(o_fpt,"else{\n");
            parse_nodes(n->cmd.if_else.if_body, o_fpt);
            fprintf(o_fpt,"}\n");
            break;

        case AST_LPAREN:
            fprintf(o_fpt,"(");
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,")");
            break;

        case AST_G:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,">");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_EQ:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"==");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_NEQ:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"!=");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_LE:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"<=");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_L:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"<");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_GE:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,">=");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_AND:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"&&");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_OR:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"||");
            parse_nodes(n->op2, o_fpt);
            break;

/* ------------ IF-ELSE ------------ */

/* ------------ CYCLES ------------ */

        case AST_FOR:
            fprintf(o_fpt,"for(;");
            parse_nodes(n->cmd.cycles.for_cycle.condition, o_fpt);
            fprintf(o_fpt,";");
            parse_nodes(n->cmd.cycles.for_cycle.iter, o_fpt);
            fprintf(o_fpt,"){\n");
            parse_nodes(n->cmd.cycles.for_cycle.for_body, o_fpt);
            fprintf(o_fpt,"}\n");
            break;

        case AST_WHILE:
            fprintf(o_fpt,"while(");
            parse_nodes(n->cmd.cycles.while_cycle.condition, o_fpt);
            fprintf(o_fpt,"){\n");
            parse_nodes(n->cmd.cycles.while_cycle.while_body, o_fpt);
            fprintf(o_fpt,"}\n");
            break;

/* ------------ CYCLES ------------ */

/* ------------ I/O ------------ */

        case AST_OUT:
            fprintf(
                o_fpt,
                "printf(\"%s\"",
                n->cmd.io.format
            );

            for (int i = 0; i < n->cmd.io.args_count; ++i) {
                fprintf(o_fpt, ",");
                parse_nodes(n->cmd.io.args[i], o_fpt);
            }
            fprintf(o_fpt, ");\n");
            break;

        case AST_IN:
            if (comp(n->cmd.io.format, "%c"))
                fprintf(o_fpt, "getc(stdin);\n");

            fprintf(
                o_fpt,
                "scanf(\"%s\"",
                n->cmd.io.format
            );

            for (int i = 0; i < n->cmd.io.args_count; ++i) {
                fprintf(o_fpt, ",");
                parse_nodes(n->cmd.io.args[i], o_fpt);
            }
            fprintf(o_fpt, ");\n");
            break;

/* ------------ I/O ------------ */

/* ------------ UNARY OP'S. ------------ */

        case AST_DEREF:
            fprintf(o_fpt,"*");
            parse_nodes(n->op1, o_fpt);
            break;

        case AST_GET_ADDR:
            fprintf(o_fpt, "&");
            parse_nodes(n->op1, o_fpt);
            break;

        case AST_INC_PREF:
            fprintf(o_fpt,"++");
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt, ";\n");
            break;

        case AST_DEC_PREF:
            fprintf(o_fpt,"--");
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt, ";\n");
            break;

        case AST_INC_POST:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"++");
            fprintf(o_fpt, ";\n");
            break;

        case AST_DEC_POST:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"--");
            fprintf(o_fpt, ";\n");
            break;

/* ------------ UNARY OP'S. ------------ */

/* ------------ BINARY OP'S. ------------ */

        case AST_PLUS:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"+");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_MINUS:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"-");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_MULTI:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"*");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_DIV:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"/");
            parse_nodes(n->op2, o_fpt);
            break;

        case AST_REM:
            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt,"%%");
            parse_nodes(n->op2, o_fpt);
            break;

/* ------------ BINARY OP'S. ------------ */

/* ------------ EXPR'S ------------ */

        case AST_LIT_CNST:
            fprintf(
                o_fpt,
                "%s",
                n->constant.name
            );
            break;

        case AST_NUM:
            if (n->constant.type == TYPE_INT)
                fprintf(o_fpt, "%d", n->constant.int_value);
            else if (n->constant.type == TYPE_LONG)
                fprintf(o_fpt, "%ld", n->constant.long_value);
            else if (n->constant.type == TYPE_FLT)
                fprintf(o_fpt, "%f", n->constant.flt_value);
            break;

        case AST_NULL_VALUE:
            fprintf(o_fpt, "NULL");
            break;

        case AST_CHAR_VALUE:
            fprintf(o_fpt, "'%c'", n->constant.char_value);
            break;

        case AST_BOOLIAN_VALUE:
            fprintf(o_fpt, "%s", n->constant.bool_value ? "true" : "false");
            break;

        case AST_ASSIGN:
        case AST_ADD_ASSIGN:
        case AST_REDUCE_ASSIGN:
        case AST_MUL_ASSIGN:
        case AST_DIV_ASSIGN:
        case AST_REM_ASSIGN:
            if (n->op1->constant.type != TYPE_NULL) {
                string type = NULL;
                if (n->op1->constant.is_unsign)
                    type = "unsigned ";

                type = !type ? str_types[n->op1->constant.type % 7] : concat(type, str_types[n->op1->constant.type % 7]);
                if (n->op1->constant.is_ptr)
                    type = concat_c(type, '*');

                fprintf(o_fpt, "%s ", type);
            }

            parse_nodes(n->op1, o_fpt);
            fprintf(o_fpt, "%s", str_assigns[n->node_type % 6]);
            parse_nodes(n->op2, o_fpt);
            fprintf(o_fpt, ";\n");
            break;
    }
}